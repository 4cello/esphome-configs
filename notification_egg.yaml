substitutions:
  devicename: notification-egg

packages:
  wifi: !include common/wifi.yaml
  device_base: !include common/device_base.yaml

esphome:
  platform: ESP8266
  board: d1_mini
  on_boot:
    priority: -200
    then:
      - light.turn_on:
          id: notification_light
          effect: "THE notification effect"

time:
  - platform: sntp
    id: sntp_time

captive_portal:

ota:

globals:
  - id: colors
    type: Color[6]
    initial_value: |-
      {
        Color(255,0,0,0), // red
        Color(0,255,0,0), // green
        Color(0,0,255,0), // blue
        Color(255,255,0,0), // yellow
        Color(0,255,255,0), // cyan
        Color(255,0,255,0) // magenta
      }
  - id: pending_notifications
    type: time_t[6]
    initial_value: |-
      {
        0,0,0,0,0,0
      }

interval:
  - interval: 10s
    then:
      - lambda: |-
          uint8_t len = sizeof(id(colors)) / sizeof(Color*);
          auto now = id(sntp_time).now();
          if (!now.is_valid()) 
            return;
          time_t utc = now.timestamp;
          for (uint8_t i = 0; i < len; i++) {
            time_t old = id(pending_notifications)[i];
            if (!old) continue;
            if (utc >= old) {
              id(pending_notifications)[i] = 0;
              ESP_LOGI("interval", "reset %u: %lli >= %lli", i, utc, old);
            }
          }
      - component.update: txt_notifications

<<: !include
  file: common/fragments/notification_light.config.yaml
  vars:
    color: red
    index: 0
<<: !include
  file: common/fragments/notification_light.config.yaml
  vars:
    color: green
    index: 1
<<: !include
  file: common/fragments/notification_light.config.yaml
  vars:
    color: blue
    index: 2
<<: !include
  file: common/fragments/notification_light.config.yaml
  vars:
    color: yellow
    index: 3
<<: !include
  file: common/fragments/notification_light.config.yaml
  vars:
    color: cyan
    index: 4
<<: !include
  file: common/fragments/notification_light.config.yaml
  vars:
    color: magenta
    index: 5

text_sensor:
  - platform: template
    name: Current Notifications
    id: txt_notifications
    entity_category: diagnostic
    lambda: |-
      std::string color_names[] = {
        "red", "green", "blue", "yellow", "cyan", "magenta"
      };
      uint8_t len = sizeof(id(colors)) / sizeof(Color*);
      char buf[50];
      std::string result = "{";
      for (uint8_t i = 0; i < len; i++) {
        sprintf(buf, "\"%s\": %lli%s",
          color_names[i].c_str(), id(pending_notifications)[i], (i == len - 1) ? "" : ",");
        result += std::string(buf);
      }
      result += std::string("}");
      return result;

font:
  - file: "fonts/comic.ttf"
    id: comicsans
    size: 20
  # gfonts://family[@weight]
  - file: "gfonts://Roboto"
    id: roboto
    size: 32

i2c:
  sda: D6
  scl: D7
  frequency: 400kHz

display:
  - platform: ssd1306_i2c
    model: "SSD1306 128x64"
    address: 0x3C
    lambda: |-
      auto time = id(sntp_time).now();
      if (time.is_valid()) {
        it.strftime(0,0, id(roboto), "%X", time);
      } else {
        it.print(0,0, id(roboto), "not synced");
      }

light:
  - platform: neopixelbus
    variant: SK6812
    type: GRBW
    pin: D2
    num_leds: 35
    name: "Notification Light"
    id: notification_light
    entity_category: config
    effects:
      - addressable_lambda:
          name: "THE notification effect"
          update_interval: 16ms
          lambda: |-
            // ---------- CONFIG START -------------
            // Width of color spot in pixels
            #define COLOR_WIDTH 3

            // How far from the end should pixels begin to fade out?
            #define FADE_OUT 5

            // Brightness of each pixel in a color spot. Length must be == COLOR_WIDTH
            static float COLOR_SHAPE[COLOR_WIDTH] = {64,128,64};

            // How many blank pixels between 2 notification spots?
            static uint8_t BETWEEN_COLORS = 5;

            // How many blank pixels until starting over?
            static uint8_t BETWEEN_CYCLES = 3*it.size();
            // ---------- CONFIG END ---------------

            // How many notification colors are there?
            static uint8_t COLOR_COUNT = sizeof(id(colors)) / sizeof(Color*);

            // Counter for space between color segments
            static uint8_t cycles_until_next_color = 0;

            // Counter for width of color segments
            static uint8_t cycles_until_color_ends = COLOR_WIDTH;

            // Counter for current notification color
            static uint8_t notification_class = 0;

            // Should be named current_color, but that one is already taken :(
            static Color next_color;

            // shift every pixel over, fading out the last couple ones
            uint8_t px = it.size()-1;
            for (; px >= it.size()-FADE_OUT-1; px--) {
              it[px] = it[px-1].get().darken(255/FADE_OUT);
            }
            // shift the rest
            for (; px > 0; px--) {
              it[px] = it[px-1].get();
            }

            // now decide which color the first pixel will be
            if (cycles_until_next_color > 0) {
              // no color is being added
              it[0] = Color::BLACK;
              cycles_until_next_color--;
            } else {
              ESP_LOGD("notify_effect", "cunc=%d, cuce=%d, nc=%d", cycles_until_next_color, cycles_until_color_ends, notification_class);
              // there is currently a color being added
              time_t is_active = id(pending_notifications)[notification_class];
              if (is_active) {
                next_color = id(colors)[notification_class];
              } else {
                next_color = Color::BLACK;
              }
              it[0] = next_color.darken(255-COLOR_SHAPE[cycles_until_color_ends-1]);
              if (cycles_until_color_ends > 0) {
                // continue to finish this color
                cycles_until_color_ends--;
              } else {
                ESP_LOGD("notify_effect", "preparing next color");
                // prepare next color
                cycles_until_color_ends = COLOR_WIDTH;
                if (notification_class >= COLOR_COUNT-1) {
                  ESP_LOGD("notify_effect", "nc >= COLOR_COUNT-1: resetting cunc");
                  // we're at notification_class >= COLOR_COUNT-1
                  // reset notification_class and prepare for full cycle
                  notification_class = 0;
                  cycles_until_next_color = BETWEEN_CYCLES;
                } else {
                  ESP_LOGD("notify_effect", "nc < COLOR_COUNT-1:");
                  // we're at some notification_class < COLOR_COUNT - 1
                  // find the next "non-empty" class
                  notification_class++;
                  for (; notification_class < COLOR_COUNT; notification_class++) {
                    is_active = id(pending_notifications)[notification_class];
                    ESP_LOGD("notify_effect", "nc = %d -> is_active = %d", notification_class, is_active);
                    if (is_active) {
                      break;
                    }
                  }
                  if (notification_class < COLOR_COUNT && is_active) {
                    ESP_LOGD("notify_effect", "found next nc: %d", notification_class);
                    // there is actually a "non-empty" class
                    // set its color and prepare small spacing
                    cycles_until_next_color = BETWEEN_COLORS;
                  } else {
                    // we arrived at notification_class == 0 without finding an active class
                    // reset notification_class and prepare for full cycle
                    notification_class = 0;
                    cycles_until_next_color = BETWEEN_CYCLES;
                  }
                }
              }
            }