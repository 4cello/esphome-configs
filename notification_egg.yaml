substitutions:
  devicename: notification-egg

packages:
  wifi: !include common/wifi.yaml
  device_base: !include common/device_base.yaml

esphome:
  platform: ESP8266
  board: d1_mini
  on_boot:
    priority: -200
    then:
      - light.turn_on:
          id: notification_light
          effect: "THE notification effect"

time:
  - platform: sntp
    id: sntp_time

captive_portal:

ota:

globals:
  - id: colors
    type: Color[6]
    initial_value: |-
      {
        Color(255,0,0,0), // red
        Color(0,255,0,0), // green
        Color(0,0,255,0), // blue
        Color(255,255,0,0), // yellow
        Color(0,255,255,0), // cyan
        Color(255,0,255,0) // magenta
      }
  - id: pending_notifications
    type: time_t[6]
    initial_value: |-
      {
        0,0,0,0,0,0
      }

interval:
  - interval: 10s
    then:
      - lambda: |-
          uint8_t len = sizeof(id(colors)) / sizeof(Color*);
          auto now = id(sntp_time).now();
          if (!now.is_valid()) 
            return;
          time_t utc = now.timestamp;
          for (uint8_t i = 0; i < len; i++) {
            time_t old = id(pending_notifications)[i];
            if (!old) continue;
            if (utc >= old) {
              id(pending_notifications)[i] = 0;
              ESP_LOGI("interval", "reset %u: %lli >= %lli", i, utc, old);
            }
          }
      - component.update: txt_notifications

mqtt:
  on_message:
    - topic: "esphome/$devicename/notify/red"
      then:
      - logger.log:
          level: INFO
          format: "Received new timestamp for RED: %s"
          args: ["x.c_str()" ]
          
      - lambda: |-
          time_t end = atoll(x.c_str());
          time_t old = id(pending_notifications)[0];
          if (end > old)
            id(pending_notifications)[0] = end;
      - component.update: txt_notifications
    - topic: "esphome/$devicename/notify/green"
      then:
      - logger.log:
          level: INFO
          format: "Received new timestamp for GREEN: %s"
          args: ["x.c_str()" ]
      - lambda: |-
          time_t end = atoll(x.c_str());
          time_t old = id(pending_notifications)[1];
          if (end > old)
            id(pending_notifications)[1] = end;
      - component.update: txt_notifications
    - topic: "esphome/$devicename/notify/blue"
      then:
      - logger.log:
          level: INFO
          format: "Received new timestamp for BLUE: %s"
          args: ["x.c_str()" ]
      - lambda: |-
          time_t end = atoll(x.c_str());
          time_t old = id(pending_notifications)[2];
          if (end > old)
            id(pending_notifications)[2] = end;
      - component.update: txt_notifications
    - topic: "esphome/$devicename/notify/yellow"
      then:
      - logger.log:
          level: INFO
          format: "Received new timestamp for YELLOW: %s"
          args: ["x.c_str()" ]
      - lambda: |-
          time_t end = atoll(x.c_str());
          time_t old = id(pending_notifications)[3];
          if (end > old)
            id(pending_notifications)[3] = end;
      - component.update: txt_notifications
    - topic: "esphome/$devicename/notify/cyan"
      then:
      - logger.log:
          level: INFO
          format: "Received new timestamp for CYAN: %s"
          args: ["x.c_str()" ]
      - lambda: |-
          time_t end = atoll(x.c_str());
          time_t old = id(pending_notifications)[4];
          if (end > old)
            id(pending_notifications)[4] = end;
      - component.update: txt_notifications
    - topic: "esphome/$devicename/notify/magenta"
      then:
      - logger.log:
          level: INFO
          format: "Received new timestamp for MAGENTA: %s"
          args: ["x.c_str()" ]
      - lambda: |-
          time_t end = atoll(x.c_str());
          time_t old = id(pending_notifications)[5];
          if (end > old)
            id(pending_notifications)[5] = end;
      - component.update: txt_notifications

button:
  - platform: template
    name: "Test RED notification"
    on_press:
      - mqtt.publish:
          topic: "esphome/$devicename/notify/red"
          payload: !lambda |-
            char buf[32]; 
            return itoa(id(sntp_time).now().timestamp + 30, buf, 10);
  - platform: template
    name: "Test GREEN notification"
    on_press:
      - mqtt.publish:
          topic: "esphome/$devicename/notify/green"
          payload: !lambda |-
            char buf[32]; 
            return itoa(id(sntp_time).now().timestamp + 30, buf, 10);
  - platform: template
    name: "Test BLUE notification"
    on_press:
      - mqtt.publish:
          topic: "esphome/$devicename/notify/blue"
          payload: !lambda |-
            char buf[32]; 
            return itoa(id(sntp_time).now().timestamp + 30, buf, 10);
  - platform: template
    name: "Test YELLOW notification"
    on_press:
      - mqtt.publish:
          topic: "esphome/$devicename/notify/yellow"
          payload: !lambda |-
            char buf[32]; 
            return itoa(id(sntp_time).now().timestamp + 30, buf, 10);
  - platform: template
    name: "Test CYAN notification"
    on_press:
      - mqtt.publish:
          topic: "esphome/$devicename/notify/cyan"
          payload: !lambda |-
            char buf[32]; 
            return itoa(id(sntp_time).now().timestamp + 30, buf, 10);
  - platform: template
    name: "Test MAGENTA notification"
    on_press:
      - mqtt.publish:
          topic: "esphome/$devicename/notify/magenta"
          payload: !lambda |-
            char buf[32]; 
            return itoa(id(sntp_time).now().timestamp + 30, buf, 10);

text_sensor:
  - platform: template
    name: Current Notifications
    id: txt_notifications
    entity_category: diagnostic
    lambda: |-
      std::string color_names[] = {
        "red", "green", "blue", "yellow", "cyan", "magenta"
      };
      uint8_t len = sizeof(id(colors)) / sizeof(Color*);
      char buf[50];
      std::string result = "{";
      for (uint8_t i = 0; i < len; i++) {
        sprintf(buf, "\"%s\": %lli%s",
          color_names[i].c_str(), id(pending_notifications)[i], (i == len - 1) ? "" : ",");
        result += std::string(buf);
      }
      result += std::string("}");
      return result;


font:
  - file: "fonts/comic.ttf"
    id: comicsans
    size: 20
  # gfonts://family[@weight]
  - file: "gfonts://Roboto"
    id: roboto
    size: 32

i2c:
  sda: D6
  scl: D7
  frequency: 400kHz

display:
  - platform: ssd1306_i2c
    model: "SSD1306 128x64"
    address: 0x3C
    lambda: |-
      auto time = id(sntp_time).now();
      if (time.is_valid()) {
        it.strftime(0,0, id(roboto), "%X", time);
      } else {
        it.print(0,0, id(roboto), "not synced");
      }

light:
  - platform: neopixelbus
    variant: SK6812
    type: GRBW
    pin: D2
    num_leds: 35
    name: "Notification Light"
    id: notification_light
    entity_category: config
    effects:
      - addressable_lambda:
          name: "THE notification effect"
          update_interval: 16ms
          lambda: |-
            // -------------------------
            #define COLOR_WIDTH 3
            #define COLOR_COUNT 6
            #define FADE_OUT 5
            static float COLOR_SHAPE[COLOR_WIDTH] = {64,128,64};//{64,85,128,255,128,85,64};
            static uint8_t BETWEEN_COLORS = 5;
            static uint8_t BETWEEN_CYCLES = 3*35;//(35-COLOR_WIDTH);
            // --------------------------
            static uint8_t cycles_until_next_color = 0;
            static uint8_t cycles_until_color_ends = COLOR_WIDTH;
            static uint8_t notification_class = 0;

            static Color next_color; // = COLORS[notification_class];

            // shift every pixel over
            uint8_t px = it.size()-1;
            for (; px >= it.size()-FADE_OUT-1; px--) {
              it[px] = it[px-1].get().darken(255/FADE_OUT);
            }
            for (; px > 0; px--) {
              it[px] = it[px-1].get();
            }

            if (cycles_until_next_color > 0) {
              // no color is being added
              it[0] = Color::BLACK;
              cycles_until_next_color--;
            } else {
              ESP_LOGD("notify_effect", "cunc=%d, cuce=%d, nc=%d", cycles_until_next_color, cycles_until_color_ends, notification_class);
              // there is currently a color being added
              time_t is_active = id(pending_notifications)[notification_class];
              if (is_active) {
                next_color = id(colors)[notification_class];
              } else {
                next_color = Color::BLACK;
              }
              it[0] = next_color.darken(255-COLOR_SHAPE[cycles_until_color_ends-1]);
              if (cycles_until_color_ends > 0) {
                // continue to finish this color
                cycles_until_color_ends--;
              } else {
                ESP_LOGD("notify_effect", "preparing next color");
                // prepare next color
                cycles_until_color_ends = COLOR_WIDTH;
                if (notification_class >= COLOR_COUNT-1) {
                  ESP_LOGD("notify_effect", "nc >= COLOR_COUNT-1: resetting cunc");
                  // we're at notification_class >= COLOR_COUNT-1
                  // reset notification_class and prepare for full cycle
                  notification_class = 0;
                  cycles_until_next_color = BETWEEN_CYCLES;
                } else {
                  ESP_LOGD("notify_effect", "nc < COLOR_COUNT-1:");
                  // we're at some notification_class < COLOR_COUNT - 1
                  // find the next "non-empty" class
                  notification_class++;
                  for (; notification_class < COLOR_COUNT; notification_class++) {
                    is_active = id(pending_notifications)[notification_class];
                    ESP_LOGD("notify_effect", "nc = %d -> is_active = %d", notification_class, is_active);
                    if (is_active) {
                      break;
                    }
                  }
                  if (notification_class < COLOR_COUNT && is_active) {
                    ESP_LOGD("notify_effect", "found next nc: %d", notification_class);
                    // there is actually a "non-empty" class
                    // set its color and prepare small spacing
                    cycles_until_next_color = BETWEEN_COLORS;
                  } else {
                    // we arrived at notification_class == 0 without finding an active class
                    // reset notification_class and prepare for full cycle
                    notification_class = 0;
                    cycles_until_next_color = BETWEEN_CYCLES;
                  }
                }
              }
            }
      - pulse: